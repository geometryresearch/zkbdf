/*

        Name: zkbdf_verify.c
        Author: Tan Teik Guan
        Description: Verify function for VDF realization using ZKBoo. Modified from MPC_SHA256_VERIFIER.c
*/

/*
 ============================================================================
 Name        : MPC_SHA256_VERIFIER.c
 Author      : Sobuno
 Version     : 0.1
 Description : Verifies a proof for SHA-256 generated by MPC_SHA256.c
 ============================================================================
 */

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include "shared.h"

int NUM_ROUNDS = 100;
int NUM_LOOPS = 1;

void printbits(uint32_t n) {
	if (n) {
		printbits(n >> 1);
		printf("%d", n & 1);
	}

}



int main(int argc, char * argv[]) {
	setbuf(stdout, NULL);
	init_EVP();
	openmp_thread_setup();
	char CHALLENGE[BLOCK_SIZE];
	char ek[BLOCK_SIZE];
	
        if (argc != 4)
        {
                printf("Usage: %s <number of rounds (e.g. 20, 40, 60, 80, 100)> <challenge (Max %d char> <eval key (Max %d char)>\n",argv[0],MSG_SIZE,MSG_SIZE);
                return -1;
        }
        NUM_ROUNDS = atoi(argv[1]);
	memset(CHALLENGE,0,sizeof(CHALLENGE));
	strncpy(CHALLENGE,argv[2],MSG_SIZE);
	memset(ek,0,sizeof(ek));
	strncpy(ek,argv[3],MSG_SIZE);

	printf("Iterations of SHA: %d\n", NUM_ROUNDS);
	int i;
	i = strlen(ek);
	printf("length of ek: %d\n",i);
	unsigned char input[BLOCK_SIZE];
	memset(input,0,sizeof(input));
	for (int j=0;j<i;j++)
		input[j] = ek[j];

	
	a as[NUM_ROUNDS];
	z zs[NUM_ROUNDS];
	FILE *file;
	int failed = 0;

	char outputFile[3*sizeof(int) + 8];
	sprintf(outputFile, "out%i.bin", NUM_ROUNDS);
	file = fopen(outputFile, "rb");
	if (!file) {
		printf("Unable to open file!");
		return -1;
	}
	fread(&as, sizeof(a), NUM_ROUNDS, file);
	fread(&zs, sizeof(z), NUM_ROUNDS, file);
	fclose(file);

	struct timeval begin, delta;
	gettimeofday(&begin,NULL);

for(int loops=0;loops<NUM_LOOPS;loops++)
{

	uint32_t y1[8];
	uint32_t y2[8];
	reconstruct(as[0].yp1[0],as[0].yp1[1],as[0].yp1[2],y1);
	reconstruct(as[0].yp2[0],as[0].yp2[1],as[0].yp2[2],y2);
	printf("Received output for H(ek): ");
	for(int i=0;i<8;i++) {
		printf("%02X", y1[i]);
	}
	printf("\n");
	printf("Received output for Hmac(ek,challenge): ");
	for(int i=0;i<8;i++) {
		printf("%02X", y2[i]);
	}
	printf("\n");

	{
		SHA256_CTX ctx;
		unsigned char expectedhash[SHA256_DIGEST_LENGTH];
		int l;

		SHA256_Init(&ctx);
		SHA256_Update(&ctx, input, strlen(input));
        	SHA256_Final(expectedhash, &ctx);

		for (l=0;l<8;l++)
		{
			uint32_t temp;
			// to take care of big endian

			unsigned char tempc[4];
			tempc[0] = expectedhash[l*4+3];
			tempc[1] = expectedhash[l*4+2];
			tempc[2] = expectedhash[l*4+1];
			tempc[3] = expectedhash[l*4];
 
			memcpy(&temp,tempc,4);
			if (temp != y1[l])
			{
				printf("hash does not match !!\n");
				return -1;
			}
		}
	}
	int es[NUM_ROUNDS*2];
	unsigned char plaintext[NUM_ROUNDS][16];
	memset(&(plaintext[0]),0x30,16);
	#pragma omp parallel for
	for (int i=0; i<(NUM_ROUNDS); i++)
	{
		if (i < (NUM_ROUNDS-1))
		{
			SHA256_CTX ctx;
			unsigned char prevroundhash[SHA256_DIGEST_LENGTH];

			SHA256_Init(&ctx);
			SHA256_Update(&ctx, &(zs[i]), sizeof(z));
			SHA256_Final(prevroundhash, &ctx);
			memcpy(plaintext[i+1],prevroundhash,16);
		}

		H3(y1,y2,&(as[i]), 1, &(es[i]));
	}

	#pragma omp parallel for
	for(int i = 0; i<(NUM_ROUNDS); i++) {
		int verifyResult = verify(as[i], CHALLENGE, es[i], plaintext[i], zs[i]);
		if (verifyResult != 0) {
			printf("Not Verified %d\n", i);
			failed = 1;
		}
	}
}
	if (!failed)
		printf("verified ok \n",i);
	
	gettimeofday(&delta,NULL);
	unsigned long inMilli = (delta.tv_sec - begin.tv_sec)*1000000 + (delta.tv_usec - begin.tv_usec);
	inMilli /= 1000;

	printf("Total time for %d loops: %ju miliseconds\n", NUM_LOOPS,(uintmax_t)inMilli);
	printf("Time for 1 loop: %ju miliseconds\n", (uintmax_t)inMilli/NUM_LOOPS);
	
	openmp_thread_cleanup();
	cleanup_EVP();
	return EXIT_SUCCESS;
}
